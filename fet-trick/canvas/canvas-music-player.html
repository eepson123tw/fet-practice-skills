<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Enhanced Music Visualizer</title>
    <style>
      /* Modern, clean design with improved aesthetics */
      :root {
        --primary: #22c55e;
        --primary-dark: #16a34a;
        --primary-light: #4ade80;
        --dark-bg: #121212;
        --darker-bg: #0a0a0a;
        --medium-bg: #1e1e1e;
        --light-bg: #2d2d2d;
        --text: #ffffff;
        --text-dim: #b3b3b3;
        --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        --glow: 0 0 15px rgba(34, 197, 94, 0.4);
      }
      
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      body {
        background-color: var(--darker-bg);
        color: var(--text);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        overflow: hidden;
        margin: 0;
        padding: 0;
        height: 100vh;
        width: 100vw;
      }
      
      .player-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      
      #visualizer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        overflow: hidden;
      }
      
      canvas {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
      }
      
      #lyrics-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 10;
        width: 80%;
        font-size: 24px;
        font-weight: bold;
        color: white;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
        pointer-events: none;
        transition: all 0.3s ease;
      }
      
      .lyrics-line {
        opacity: 0.3;
        transition: all 0.3s ease;
        margin: 8px 0;
        filter: blur(1px);
      }
      
      .lyrics-active {
        opacity: 1;
        font-size: 1.2em;
        filter: blur(0);
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      }
      
      #song-info {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: var(--medium-bg);
        padding: 16px 24px;
        border-radius: 12px;
        width: 90%;
        max-width: 600px;
        text-align: center;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        z-index: 20;
      }
      
      #song-title {
        font-size: 26px;
        font-weight: bold;
        margin-bottom: 6px;
      }
      
      #artist {
        font-size: 18px;
        color: var(--text-dim);
      }
      
      .vis-controls {
        position: absolute;
        top: 100px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 12px;
        width: 90%;
        max-width: 600px;
        justify-content: center;
        z-index: 20;
      }
      
      .vis-btn {
        background-color: var(--light-bg);
        color: var(--text);
        border: none;
        border-radius: 8px;
        padding: 10px 18px;
        font-size: 15px;
        cursor: pointer;
        transition: all 0.2s ease;
        flex-grow: 1;
        max-width: 160px;
        text-align: center;
      }
      
      .vis-btn:hover:not(.active) {
        background-color: #3a3a3a;
        transform: translateY(-2px);
      }
      
      .vis-btn.active {
        background-color: var(--primary);
        box-shadow: var(--glow);
      }
      
      /* Progress bar styling */
      #progress-container {
        position: absolute;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        width: 90%;
        max-width: 800px;
        height: 8px;
        background-color: var(--light-bg);
        border-radius: 4px;
        cursor: pointer;
        overflow: hidden;
        z-index: 20;
      }
      
      #progress-bar {
        height: 100%;
        background: linear-gradient(90deg, var(--primary), var(--primary-light));
        border-radius: 4px;
        width: 0;
        transition: width 0.1s linear;
      }
      
      #progress-bar::after {
        content: '';
        position: absolute;
        height: 14px;
        width: 14px;
        background-color: white;
        border-radius: 50%;
        top: 50%;
        right: 0;
        transform: translate(50%, -50%) scale(0);
        transition: transform 0.2s ease;
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
      }
      
      #progress-container:hover #progress-bar::after {
        transform: translate(50%, -50%) scale(1);
      }
      
      #time-display {
        position: absolute;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        justify-content: space-between;
        width: 90%;
        max-width: 800px;
        font-size: 14px;
        color: var(--text-dim);
        z-index: 20;
      }
      
      .controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        gap: 28px;
        justify-content: center;
        z-index: 20;
      }
      
      .play-btn {
        width: 64px;
        height: 64px;
        border-radius: 50%;
        background-color: var(--primary);
        border: none;
        color: white;
        font-size: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }
      
      .play-btn:hover {
        background-color: var(--primary-dark);
        transform: scale(1.05);
        box-shadow: var(--glow);
      }
      
      .play-btn:active {
        transform: scale(0.98);
      }
      
      #volume-container {
        display: flex;
        align-items: center;
        gap: 10px;
        background-color: var(--medium-bg);
        padding: 6px 16px;
        border-radius: 8px;
      }
      
      #volume-slider {
        -webkit-appearance: none;
        width: 100px;
        height: 5px;
        border-radius: 2px;
        background: #535353;
        outline: none;
      }
      
      #volume-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--primary);
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      #volume-slider::-webkit-slider-thumb:hover {
        background: var(--primary-light);
        transform: scale(1.1);
        box-shadow: 0 0 8px rgba(34, 197, 94, 0.6);
      }
      
      .volume-icon {
        color: var(--text-dim);
      }
      
      .keyboard-shortcuts {
        position: absolute;
        bottom: 150px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 14px;
        color: var(--text-dim);
        text-align: center;
        padding: 12px 16px;
        background-color: var(--medium-bg);
        border-radius: 8px;
        opacity: 0.8;
        transition: opacity 0.2s ease;
        z-index: 20;
      }
      
      .keyboard-shortcuts:hover {
        opacity: 1;
      }
      
      .key {
        display: inline-block;
        background-color: var(--light-bg);
        border-radius: 4px;
        padding: 2px 6px;
        margin: 0 4px;
        font-family: monospace;
        box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
      }
      
      /* Responsive adjustments */
      @media (max-width: 768px) {
        .vis-controls {
          flex-wrap: wrap;
        }
        
        .vis-btn {
          flex-basis: 100%;
          max-width: none;
        }
        
        .controls {
          flex-direction: column;
          gap: 16px;
        }
      }
    </style>
  </head>
  <body>
    <div class="player-container">
      <div id="visualizer">
        <div id="lyrics-container"></div>
        <canvas id="canvas"></canvas>
      </div>

      <div id="song-info">
        <div id="song-title">Find Your Problems</div>
        <div id="artist">Visualizer Demo</div>
      </div>
      
      <div class="vis-controls">
        <button class="vis-btn active" id="circle-btn">Circles</button>
        <button class="vis-btn" id="square-btn">Squares</button>
        <button class="vis-btn" id="triangle-btn">Triangles</button>
        <button class="vis-btn" id="line-btn">Lines</button>
        <button class="vis-btn" id="star-btn">Stars</button>
      </div>

      <div id="progress-container">
        <div id="progress-bar"></div>
      </div>

      <div id="time-display">
        <span id="current-time">0:00</span>
        <span id="duration">0:00</span>
      </div>

      <div class="controls">
        <button class="play-btn" id="play-btn">â–¶</button>
        <div id="volume-container">
          <span class="volume-icon">ðŸ”Š</span>
          <input
            type="range"
            id="volume-slider"
            min="0"
            max="1"
            step="0.01"
            value="0.7"
          />
        </div>
      </div>
      
      <div class="keyboard-shortcuts">
        Keyboard shortcuts: <span class="key">Space</span> Play/Pause 
        <span class="key">C</span> Circles 
        <span class="key">S</span> Squares 
        <span class="key">T</span> Triangles
        <span class="key">L</span> Lines
        <span class="key">*</span> Stars
      </div>
    </div>

    <script>
      // DOM Elements
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const visualizer = document.getElementById("visualizer");
      const playBtn = document.getElementById("play-btn");
      const progressContainer = document.getElementById("progress-container");
      const progressBar = document.getElementById("progress-bar");
      const currentTimeEl = document.getElementById("current-time");
      const durationEl = document.getElementById("duration");
      const volumeSlider = document.getElementById("volume-slider");
      const songTitleEl = document.getElementById("song-title");
      const artistEl = document.getElementById("artist");
      const lyricsContainer = document.getElementById("lyrics-container");
      const circleBtn = document.getElementById("circle-btn");
      const squareBtn = document.getElementById("square-btn");
      const triangleBtn = document.getElementById("triangle-btn");
      const lineBtn = document.getElementById("line-btn");
      const starBtn = document.getElementById("star-btn");

      // Use an online sample audio file to ensure it works without local files
      const defaultSongPath = './Find_Your_Problems.mp3';
      const defaultLyricsPath = './lyrics.srt';

      // Audio setup
      let audioContext;
      let analyser;
      let source;
      let dataArray;
      let bufferLength;
      let audio = new Audio();
      let isPlaying = false;
      let animationId;
      let lastCalledTime;
      let fps;

      // Kaleidoscope setup
      let kaleidoscopeSegments = 12;
      let particles = [];
      const particleCount = 200; // More particles for more complex patterns
      let hues = [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330]; // More color options
      let currentHue = 0;
      let patternMode = 0; // Different pattern modes

      // Shape selection (0: circle, 1: square, 2: triangle, 3: line, 4: star)
      let selectedShape = 0;
      
      // Visualization state
      let bassValue = 0;
      let midValue = 0;
      let trebleValue = 0;
      let colorOffset = 0;

      // Lyrics state
      let lyrics = [];
      let currentLyricIndex = -1;
      let showingLyrics = false;
      
      /**
       * Parse WebVTT/SRT content into an array of cue objects
       */
      function parseVTT(vttContent) {
        const cues = [];
        
        // Split the content by line breaks
        const lines = vttContent.trim().split('\n');
        
        // Check if the first line is the WebVTT header
        let startIndex = 0;
        if (lines[0].indexOf('WEBVTT') === 0) {
          startIndex = 1;
        }
        
        let currentCue = null;
        
        // Process each line
        for (let i = startIndex; i < lines.length; i++) {
          const line = lines[i].trim();
          
          // Skip empty lines
          if (!line) continue;
          
          // Skip index numbers (optional in WebVTT)
          if (/^\d+$/.test(line)) continue;
          
          // Check if line contains a timestamp
          if (line.indexOf('-->') !== -1) {
            // Parse timestamps
            const timestamps = line.split('-->').map(t => t.trim());
            
            // Convert timestamp to seconds
            const startTime = parseTimestamp(timestamps[0]);
            const endTime = parseTimestamp(timestamps[1]);
            
            // Create new cue
            currentCue = {
              start: startTime,
              end: endTime,
              text: ''
            };
            
            cues.push(currentCue);
          } 
          // If not a timestamp and we have a current cue, it's the text content
          else if (currentCue) {
            // If the cue already has text, add a line break before adding more
            if (currentCue.text) {
              currentCue.text += '\n' + line;
            } else {
              currentCue.text = line;
            }
          }
        }
        
        return cues;
      }

      /**
       * Convert WebVTT timestamp to seconds
       */
      function parseTimestamp(timestamp) {
        // Handle both formats: "MM:SS.mmm" and "HH:MM:SS.mmm"
        let parts = timestamp.split(':');
        let seconds = 0;
        
        if (parts.length === 3) {
          // HH:MM:SS.mmm format
          seconds += parseFloat(parts[0]) * 3600; // Hours
          seconds += parseFloat(parts[1]) * 60;   // Minutes
          seconds += parseFloat(parts[2]);        // Seconds
        } else if (parts.length === 2) {
          // MM:SS.mmm format
          seconds += parseFloat(parts[0]) * 60;   // Minutes
          seconds += parseFloat(parts[1]);        // Seconds
        }
        
        return seconds;
      }
      
      // Function to detect if a file is a subtitle file
      function isSubtitleFile(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        return ['vtt', 'srt', 'lrc'].includes(ext);
      }

      // Initialize canvas dimensions
      function resizeCanvas() {
        // Make canvas full browser window size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // Initialize visualization
      function initAudio() {
        if (!audioContext) {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 2048;
          bufferLength = analyser.frequencyBinCount;
          dataArray = new Uint8Array(bufferLength);

          createParticles();
        }

        // Connect the audio source
        if (source) {
          source.disconnect();
        }

        source = audioContext.createMediaElementSource(audio);
        source.connect(analyser);
        analyser.connect(audioContext.destination);
      }

      // Create particles for kaleidoscope
      function createParticles() {
        particles = [];
        for (let i = 0; i < particleCount; i++) {
          particles.push({
            x: canvas.width / 2,
            y: canvas.height / 2,
            size: Math.random() * 8 + 1, // More varied sizes
            speed: Math.random() * 3 + 0.2,
            angle: Math.random() * Math.PI * 2,
            hue: hues[Math.floor(Math.random() * hues.length)],
            alpha: Math.random() * 0.7 + 0.3,
            // Use selected shape instead of random
            shape: selectedShape,
            // Add rotation
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.05,
            // Add pulse effect
            pulse: Math.random() * 0.5 + 0.5,
            pulseSpeed: Math.random() * 0.1 + 0.02,
          });
        }
      }

      // Update frequency bands (bass, mid, treble)
      function updateFrequencyBands() {
        analyser.getByteFrequencyData(dataArray);

        // Bass: 20-250Hz (~0-10 in our array with 44100Hz sample rate)
        let bassSum = 0;
        for (let i = 1; i < 10; i++) {
          bassSum += dataArray[i];
        }
        bassValue = bassSum / 10 / 255;

        // Mid-range: 250-2000Hz (~10-40)
        let midSum = 0;
        for (let i = 10; i < 40; i++) {
          midSum += dataArray[i];
        }
        midValue = midSum / 30 / 255;

        // Treble: 2000-20000Hz (~40-100)
        let trebleSum = 0;
        for (let i = 40; i < 100; i++) {
          trebleSum += dataArray[i];
        }
        trebleValue = trebleSum / 60 / 255;

        // Use bass for kaleidoscope effects
        if (bassValue > 0.6) {
          currentHue = (currentHue + 5) % 360;
          // Randomly change pattern mode on strong bass hits
          if (Math.random() < 0.2) {
            patternMode = Math.floor(Math.random() * 5);
          }
        }

        // Change number of kaleidoscope segments based on mid frequencies
        kaleidoscopeSegments = 4 + Math.floor(midValue * 12);

        // Increase color offset based on treble
        colorOffset += trebleValue * 0.8;

        // Randomly shift colors for some particles based on audio
        if (Math.random() < bassValue * 0.3) {
          for (let i = 0; i < particles.length; i++) {
            if (Math.random() < 0.1) {
              particles[i].hue =
                (particles[i].hue + Math.floor(Math.random() * 60)) % 360;
            }
          }
        }
      }

      // Draw kaleidoscope
      function drawKaleidoscope() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Apply background glow based on bass
        const bgAlpha = bassValue * 0.15;
        ctx.fillStyle = `rgba(0, 0, 0, ${1 - bgAlpha})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Save the center point
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Update particles
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];

          // Update pulse
          p.pulse += p.pulseSpeed * (bassValue > 0.5 ? 2 : 1);
          const pulseFactor = 0.5 + Math.sin(p.pulse) * 0.5;

          // Update rotation
          p.rotation += p.rotationSpeed * (midValue > 0.5 ? 1.5 : 1);

          // Update position based on audio and pattern mode
          p.speed = 0.2 + bassValue * 3;

          // Different movement patterns based on mode
          switch (patternMode) {
            case 0: // Radial
              p.x += Math.cos(p.angle) * p.speed;
              p.y += Math.sin(p.angle) * p.speed;
              break;
            case 1: // Spiral
              p.angle += 0.02 * midValue;
              p.x += Math.cos(p.angle) * p.speed;
              p.y += Math.sin(p.angle) * p.speed;
              break;
            case 2: // Wave
              p.x += Math.cos(p.angle) * p.speed;
              p.y += Math.sin(p.angle + performance.now() * 0.001) * p.speed;
              break;
            case 3: // Chaotic
              p.angle += (Math.random() - 0.5) * 0.2 * trebleValue;
              p.x += Math.cos(p.angle) * p.speed;
              p.y += Math.sin(p.angle) * p.speed;
              break;
            case 4: // Grid
              p.x += (p.x % 20 < 10 ? 1 : -1) * p.speed * 0.5;
              p.y += (p.y % 20 < 10 ? 1 : -1) * p.speed * 0.5;
              break;
          }

          // Out of bounds - reset
          const dist = Math.sqrt((p.x - centerX) ** 2 + (p.y - centerY) ** 2);
          if (dist > Math.min(canvas.width, canvas.height) / 1.5) {
            p.x = centerX;
            p.y = centerY;
            p.angle = Math.random() * Math.PI * 2;
            p.hue = (currentHue + Math.random() * 120) % 360;
            p.shape = selectedShape; // Use the selected shape
          }

          // Draw the original particle
          ctx.save();
          ctx.translate(centerX, centerY);

          // Draw multiple copies for kaleidoscope effect
          for (let j = 0; j < kaleidoscopeSegments; j++) {
            ctx.rotate((Math.PI * 2) / kaleidoscopeSegments);

            // Mirror effect
            const relX = p.x - centerX;
            const relY = p.y - centerY;

            // Set color based on frequency bands and position
            const hue = (p.hue + colorOffset) % 360;
            const saturation = 70 + midValue * 30;
            const lightness = 40 + trebleValue * 60;
            const dynamicAlpha = p.alpha * (0.7 + pulseFactor * 0.3);

            // Apply size variations based on audio
            const dynamicSize =
              p.size * (0.8 + pulseFactor * 0.4) * (1 + bassValue);

            ctx.save();
            ctx.translate(relX, relY);
            ctx.rotate(p.rotation);

            // Draw different shapes based on shape property
            ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${dynamicAlpha})`;
            ctx.strokeStyle = `hsla(${(hue + 60) % 360}, ${saturation}%, ${lightness}%, ${dynamicAlpha * 0.8})`;
            ctx.lineWidth = 1 + trebleValue;

            switch (p.shape) {
              case 0: // Circle
                ctx.beginPath();
                ctx.arc(0, 0, dynamicSize, 0, Math.PI * 2);
                ctx.fill();
                break;
              case 1: // Square
                ctx.fillRect(
                  -dynamicSize,
                  -dynamicSize,
                  dynamicSize * 2,
                  dynamicSize * 2,
                );
                break;
              case 2: // Triangle
                ctx.beginPath();
                ctx.moveTo(0, -dynamicSize);
                ctx.lineTo(dynamicSize, dynamicSize);
                ctx.lineTo(-dynamicSize, dynamicSize);
                ctx.closePath();
                ctx.fill();
                break;
              case 3: // Line
                ctx.beginPath();
                ctx.moveTo(-dynamicSize, 0);
                ctx.lineTo(dynamicSize, 0);
                ctx.lineWidth = dynamicSize / 2;
                ctx.stroke();
                break;
              case 4: // Star
                drawStar(0, 0, 5, dynamicSize, dynamicSize / 2);
                ctx.fill();
                break;
            }

            ctx.restore();

            // Mirror
            ctx.save();
            ctx.translate(-relX, relY);
            ctx.rotate(-p.rotation);

            // Complementary color for the mirror
            ctx.fillStyle = `hsla(${(hue + 180) % 360}, ${saturation}%, ${lightness}%, ${dynamicAlpha})`;
            ctx.strokeStyle = `hsla(${(hue + 240) % 360}, ${saturation}%, ${lightness}%, ${dynamicAlpha * 0.8})`;

            switch (p.shape) {
              case 0: // Circle
                ctx.beginPath();
                ctx.arc(0, 0, dynamicSize, 0, Math.PI * 2);
                ctx.fill();
                break;
              case 1: // Square
                ctx.fillRect(
                  -dynamicSize,
                  -dynamicSize,
                  dynamicSize * 2,
                  dynamicSize * 2,
                );
                break;
              case 2: // Triangle
                ctx.beginPath();
                ctx.moveTo(0, -dynamicSize);
                ctx.lineTo(dynamicSize, dynamicSize);
                ctx.lineTo(-dynamicSize, dynamicSize);
                ctx.closePath();
                ctx.fill();
                break;
              case 3: // Line
                ctx.beginPath();
                ctx.moveTo(-dynamicSize, 0);
                ctx.lineTo(dynamicSize, 0);
                ctx.lineWidth = dynamicSize / 2;
                ctx.stroke();
                break;
              case 4: // Star
                drawStar(0, 0, 5, dynamicSize, dynamicSize / 2);
                ctx.fill();
                break;
            }

            ctx.restore();
          }

          ctx.restore();
        }
      }

      // Helper function to draw a star
      function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
        let rot = (Math.PI / 2) * 3;
        let x = cx;
        let y = cy;
        let step = Math.PI / spikes;

        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);

        for (let i = 0; i < spikes; i++) {
          x = cx + Math.cos(rot) * outerRadius;
          y = cy + Math.sin(rot) * outerRadius;
          ctx.lineTo(x, y);
          rot += step;

          x = cx + Math.cos(rot) * innerRadius;
          y = cy + Math.sin(rot) * innerRadius;
          ctx.lineTo(x, y);
          rot += step;
        }

        ctx.lineTo(cx, cy - outerRadius);
        ctx.closePath();
      }
      
      // Update lyrics based on current time
      function updateLyrics() {
        if (!showingLyrics || lyrics.length === 0) return;
        
        const currentTime = audio.currentTime;
        
        // Find the current lyric by looking for the cue that contains the current time
        let newLyricIndex = -1;
        for (let i = 0; i < lyrics.length; i++) {
          if (currentTime >= lyrics[i].start && currentTime <= lyrics[i].end) {
            newLyricIndex = i;
            break;
          }
        }
        
        // If we couldn't find an exact match, look for the nearest upcoming lyric
        if (newLyricIndex === -1) {
          for (let i = 0; i < lyrics.length; i++) {
            if (currentTime < lyrics[i].start) {
              newLyricIndex = i - 1; // The previous lyric or -1 if we're before all lyrics
              break;
            }
          }
          // If we're past all lyrics, point to the last one
          if (newLyricIndex === -1 && lyrics.length > 0) {
            newLyricIndex = lyrics.length - 1;
          }
        }
        
        // Only update the display if the lyric has changed
        if (newLyricIndex !== currentLyricIndex) {
          currentLyricIndex = newLyricIndex;
          updateLyricsDisplay();
        }
        
        // Apply animation effects
        if (currentLyricIndex >= 0) {
          // Animate lyrics based on bass
          const scale = 1 + bassValue * 0.2;
          lyricsContainer.style.transform = `translate(-50%, -50%) scale(${scale})`;
          
          // Change color based on frequencies
          const hue = (currentHue + colorOffset) % 360;
          
          // Apply color to active lyrics
          const activeElements = lyricsContainer.getElementsByClassName('lyrics-active');
          for (let el of activeElements) {
            el.style.color = `hsl(${hue}, 100%, 80%)`;
            el.style.textShadow = `0 0 10px hsl(${hue}, 100%, 50%), 
                                    0 0 20px hsl(${hue}, 100%, 50%),
                                    2px 2px 4px rgba(0, 0, 0, 0.8)`;
            
            // Pulse size with bass
            el.style.transform = `scale(${1 + bassValue * 0.15})`;
          }
        }
      }
      
      // Update the lyrics display with the current and neighboring lyrics
      function updateLyricsDisplay() {
        lyricsContainer.innerHTML = '';
        
        if (currentLyricIndex === -1 || lyrics.length === 0) {
          return;
        }
        
        // Display previous, current, and next lyrics (if available)
        // This creates a karaoke-like effect with multiple lines
        const startIdx = Math.max(0, currentLyricIndex - 1);
        const endIdx = Math.min(lyrics.length - 1, currentLyricIndex + 1);
        
        for (let i = startIdx; i <= endIdx; i++) {
          const lyricEl = document.createElement('div');
          lyricEl.textContent = lyrics[i].text;
          lyricEl.className = 'lyrics-line';
          
          if (i === currentLyricIndex) {
            lyricEl.classList.add('lyrics-active');
          }
          
          lyricsContainer.appendChild(lyricEl);
        }
      }
      
      // Main animation function
      function animate() {
        animationId = requestAnimationFrame(animate);

        if (!isPlaying) return;

        // Update FPS calculation
        if (!lastCalledTime) {
          lastCalledTime = performance.now();
          fps = 0;
          return;
        }

        const delta = (performance.now() - lastCalledTime) / 1000;
        lastCalledTime = performance.now();
        fps = 1 / delta;

        // Get frequency data
        analyser.getByteFrequencyData(dataArray);
        updateFrequencyBands();

        // Always use kaleidoscope mode
        drawKaleidoscope();
        
        // Update lyrics display
        updateLyrics();
      }

      // Play/pause toggle
      function togglePlay() {
        if (audioContext && audioContext.state === "suspended") {
          audioContext.resume();
        }

        if (isPlaying) {
          audio.pause();
          playBtn.textContent = "â–¶";
        } else {
          audio.play();
          playBtn.textContent = "âšâš";
          if (!animationId) {
            animate();
          }
        }

        isPlaying = !isPlaying;
      }

      // Format time in MM:SS
      function formatTime(seconds) {
        const min = Math.floor(seconds / 60);
        const sec = Math.floor(seconds % 60);
        return `${min}:${sec < 10 ? "0" + sec : sec}`;
      }

      // Update progress bar
      function updateProgress() {
        const { currentTime, duration } = audio;
        const progressPercent = (currentTime / duration) * 100;
        progressBar.style.width = `${progressPercent}%`;
        currentTimeEl.textContent = formatTime(currentTime);
        durationEl.textContent = formatTime(duration);
      }

      // Set progress bar on click
      function setProgress(e) {
        const width = this.clientWidth;
        const clickX = e.offsetX;
        const duration = audio.duration;
        audio.currentTime = (clickX / width) * duration;
      }
      
      // Basic LRC format parser
      function parseLRC(lrcContent) {
        const lines = lrcContent.split('\n');
        const cues = [];
        
        // Regular expression to match time tags like [mm:ss.xx]
        const timeTagRegex = /\[(\d{2}):(\d{2})\.(\d{2})\]/g;
        
        lines.forEach(line => {
          // Skip empty lines or metadata lines
          if (!line.trim() || line.startsWith('[ar:') || line.startsWith('[ti:') || 
              line.startsWith('[al:') || line.startsWith('[by:') || line.startsWith('[offset:')) {
            return;
          }
          
          // Extract all time tags from the line
          const timeMatches = [...line.matchAll(timeTagRegex)];
          if (timeMatches.length === 0) return;
          
          // Extract the lyric text (everything after the last time tag)
          const lastTagIndex = timeMatches[timeMatches.length - 1].index + timeMatches[timeMatches.length - 1][0].length;
          const text = line.substring(lastTagIndex).trim();
          
          // Create a cue for each time tag with the same text
          timeMatches.forEach(match => {
            const minutes = parseInt(match[1]);
            const seconds = parseInt(match[2]);
            const hundredths = parseInt(match[3]);
            
            const startTime = minutes * 60 + seconds + (hundredths / 100);
            
            cues.push({
              start: startTime,
              end: startTime + 5, // Default duration of 5 seconds - will be adjusted later
              text: text
            });
          });
        });
        
        // Sort cues by start time
        cues.sort((a, b) => a.start - b.start);
        
        // Adjust end times based on the next cue's start time
        for (let i = 0; i < cues.length - 1; i++) {
          cues[i].end = cues[i + 1].start;
        }
        
        return cues;
      }

      // Function to draw the bars visualization - not used but required as a placeholder
      function drawBars() {
        // This function is no longer used, but kept for reference
        console.log("Bars visualization is not implemented in this version");
      }

      // Function to draw the waveform visualization - not used but required as a placeholder
      function drawWaveform() {
        // This function is no longer used, but kept for reference
        console.log("Waveform visualization is not implemented in this version");
      }
      
      // Function to load the default audio and lyrics files
      async function loadDefaultFiles() {
        try {
          // Load the default audio file
          const audioResponse = await fetch(defaultSongPath);
          if (!audioResponse.ok) {
            throw new Error(`Failed to load audio file: ${audioResponse.status} ${audioResponse.statusText}`);
          }
          
          const audioBlob = await audioResponse.blob();
          const audioURL = URL.createObjectURL(audioBlob);
          audio.src = audioURL;
          
          // Display file info
          songTitleEl.textContent = "Find the problem";
          artistEl.textContent = "Music Visualizer";
          
          // Initialize audio if needed
          if (!audioContext) {
            initAudio();
          }
          
          // Try to load the default lyrics file
          try {
            const lyricsResponse = await fetch(defaultLyricsPath);
            if (lyricsResponse.ok) {
              const lyricsText = await lyricsResponse.text();
              // Attempt to determine format and parse
              if (lyricsText.includes('-->')) {
                lyrics = parseVTT(lyricsText);
              } else if (lyricsText.includes('[')) {
                lyrics = parseLRC(lyricsText);
              }
              
              // Set up lyrics display
              currentLyricIndex = -1;
              showingLyrics = lyrics.length > 0;
              console.log(`Loaded ${lyrics.length} lyrics`);
            } else {
              console.log('No lyrics file found or unable to load lyrics');
              showingLyrics = false;
              lyrics = [];
            }
          } catch (error) {
            console.log('Error loading lyrics, continuing without lyrics');
            showingLyrics = false;
            lyrics = [];
          }
          
          // Setup audio playback
          audio.load();
          audio.onloadedmetadata = () => {
            durationEl.textContent = formatTime(audio.duration);
            audio.play();
            isPlaying = true;
            playBtn.textContent = "âšâš";
            
            if (!animationId) {
              animate();
            }
          };
          
          return true;
        } catch (error) {
          console.error('Error loading default files:', error);
          alert(`Error loading default files: ${error.message}\nTrying to continue with demo mode.`);
          
          // Create a fallback audio context for demo mode without audio
          if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            
            // Fill with random data for a demo effect
            setInterval(() => {
              for (let i = 0; i < dataArray.length; i++) {
                dataArray[i] = Math.random() * 255;
              }
              bassValue = Math.random() * 0.8;
              midValue = Math.random() * 0.8;
              trebleValue = Math.random() * 0.8;
            }, 100);
            
            createParticles();
            isPlaying = true;
            animate();
          }
          
          return false;
        }
      }
      
      // Shape selection event listeners
      circleBtn.addEventListener("click", () => {
        selectedShape = 0;
        updateShapeButtons();
        createParticles(); // Recreate particles with new shape
      });

      squareBtn.addEventListener("click", () => {
        selectedShape = 1;
        updateShapeButtons();
        createParticles();
      });

      triangleBtn.addEventListener("click", () => {
        selectedShape = 2;
        updateShapeButtons();
        createParticles();
      });

      lineBtn.addEventListener("click", () => {
        selectedShape = 3;
        updateShapeButtons();
        createParticles();
      });

      starBtn.addEventListener("click", () => {
        selectedShape = 4;
        updateShapeButtons();
        createParticles();
      });

      // Update the active button highlighting
      function updateShapeButtons() {
        circleBtn.classList.toggle("active", selectedShape === 0);
        squareBtn.classList.toggle("active", selectedShape === 1);
        triangleBtn.classList.toggle("active", selectedShape === 2);
        lineBtn.classList.toggle("active", selectedShape === 3);
        starBtn.classList.toggle("active", selectedShape === 4);
      }
      
      // Add keyboard shortcuts
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          togglePlay();
        } else if (e.code === "KeyC") {
          selectedShape = 0; // Circle
          updateShapeButtons();
          createParticles();
        } else if (e.code === "KeyS") {
          selectedShape = 1; // Square
          updateShapeButtons();
          createParticles();
        } else if (e.code === "KeyT") {
          selectedShape = 2; // Triangle
          updateShapeButtons();
          createParticles();
        } else if (e.code === "KeyL") {
          selectedShape = 3; // Line
          updateShapeButtons();
          createParticles();
        } else if (e.code === "Digit8" && e.shiftKey) {
          selectedShape = 4; // Star (*) 
          updateShapeButtons();
          createParticles();
        }
      });

      // Event listeners
      playBtn.addEventListener("click", togglePlay);
      audio.addEventListener("timeupdate", updateProgress);
      audio.addEventListener("ended", () => {
        playBtn.textContent = "â–¶";
        isPlaying = false;
        progressBar.style.width = "0%";
      });
      progressContainer.addEventListener("click", setProgress);
      volumeSlider.addEventListener("input", () => {
        audio.volume = volumeSlider.value;
      });

      // Initialize with default volume
      audio.volume = volumeSlider.value;
      
      // Initial welcome animation function
      function initialAnimation() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw a simplified kaleidoscope pattern
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Draw welcome message
        ctx.fillStyle = "white";
        ctx.font = "30px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Fullscreen Kaleidoscope Music Visualizer", centerX, centerY - 80);
        ctx.font = "24px Arial";
        ctx.fillText("Select your preferred shape:", centerX, centerY - 30);
        ctx.fillText("Circles, Squares, Triangles, Lines, or Stars", centerX, centerY + 10);
        ctx.fillText(
          "Press Space or click Play to begin",
          centerX,
          centerY + 60
        );

        // Draw some placeholder patterns
        ctx.save();
        ctx.translate(centerX, centerY);

        for (let i = 0; i < 12; i++) {
          ctx.rotate((Math.PI * 2) / 12);

          // Draw different shapes based on time to create animation
          const time = performance.now() / 1000;
          const shape = Math.floor(time % 5);
          
          // Use different colors for each segment
          ctx.fillStyle = `hsla(${(i * 30) % 360}, 70%, 50%, 0.5)`;
          ctx.strokeStyle = `hsla(${((i * 30) + 180) % 360}, 70%, 50%, 0.5)`;
          ctx.lineWidth = 2;
          
          // Size that pulses
          const size = 50 + Math.sin(time * 2) * 20;
          
          // Draw different shapes for demo
          switch(shape) {
            case 0: // Circle
              ctx.beginPath();
              ctx.arc(100, 0, size/2, 0, Math.PI * 2);
              ctx.fill();
              break;
            case 1: // Square
              ctx.fillRect(100 - size/2, -size/2, size, size);
              break;
            case 2: // Triangle
              ctx.beginPath();
              ctx.moveTo(100, -size/2);
              ctx.lineTo(100 + size/2, size/2);
              ctx.lineTo(100 - size/2, size/2);
              ctx.closePath();
              ctx.fill();
              break;
            case 3: // Line
              ctx.beginPath();
              ctx.moveTo(100 - size/2, 0);
              ctx.lineTo(100 + size/2, 0);
              ctx.lineWidth = size/4;
              ctx.stroke();
              break;
            case 4: // Star
              ctx.save();
              ctx.translate(100, 0);
              drawStar(0, 0, 5, size/2, size/4);
              ctx.fill();
              ctx.restore();
              break;
          }
        }

        ctx.restore();

        // This will cancel the animation once audio starts playing
        if (!isPlaying) {
          requestAnimationFrame(initialAnimation);
        }
      }

      // Start the initial animation
      initialAnimation();

      // Load the default files automatically when the page loads
      window.addEventListener('load', () => {
        loadDefaultFiles();
      });
    </script>
  </body>
</html>
